## Standard pieces for setting up WrapIt tests with CMake

# This files needs:
#  - wrapit executable, which will be looked for in the standard program path.
# Its location can be specified with -DWRAPIT=...
#
#  - print-cxx-path.jl, which will be looked for in the same directory containing
# this file
#
# Assumptions:
#
# - the test script is named run<PROJECT_NAME>.jl, with <PROJECT_NAME> the cmake projet name
# - the wit file is named <PROJECT_NAME>.wit
# - the module_name defined in the wit file is the same as <PROJECT_NAME>
# - the produced wrapper shared library must be named libjl<PROJECT_NAME>, placed in the
#   <PROJECT_NAME>/deps folder and the lib_basename wit parameter is set to
#   "$(@__DIR__)/../deps/libjl<PROJECT_NAME>
#
# Note @PROJECT_NAME@ can be usd in the wit.in place of the explicit project and module name.
# It will be replaced by the value define by the project() CMakeLists.txt statement when generating
# the actual .wit file from the .wit.in

# Path for CxxWrap cmake files:
find_program(PRINT_CXXWRAP_PATH print-cxxwrap-path.jl
  PATHS "${CMAKE_CURRENT_LIST_DIR}/../buildtools")

if(PRINT_CXXWRAP_PATH STREQUAL PRINT_CXXWRAP_PATH-NOTFOUND)
  message(FATAL_ERROR "Failed to find the print-cxxwarp-path.jl build tool.")
endif()

execute_process(
  COMMAND "${PRINT_CXXWRAP_PATH}"
  OUTPUT_STRIP_TRAILING_WHITESPACE
  OUTPUT_VARIABLE CXXWRAP_PREFIX
  RESULT_VARIABLE result)

if(NOT result EQUAL 0)
  message(FATAL_ERROR "Execution of ${PRINT_CXXWRAP_PATH} failed")
endif()

list(APPEND CMAKE_PREFIX_PATH ${CXXWRAP_PREFIX})

# Some standard options and paths
set(CMAKE_MACOSX_RPATH 1)
#set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${CMAKE_PROJECT_NAME}/deps")

# Loaction of JLCxx - this should be injected via DCMAKE_PREFIX_PATH
# from the CxxWrap.prefix_path() in Julia
find_package(JlCxx)
get_target_property(JlCxx_location JlCxx::cxxwrap_julia LOCATION)
get_filename_component(JlCxx_location ${JlCxx_location} DIRECTORY)
set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib;${JlCxx_location}")

message(STATUS "Found JlCxx at ${JlCxx_location}")

# C++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CXX_EXTENSIONS OFF)

# Wrapit verbosity
set(WRAPIT_VERBOSITY 1 CACHE STRING "Define verbosity level of the wrapit command. An integer, 0 for a quiet mode, 1 for a normal mode, higher numbers for a verbosity that increases with the number.")

# Find wrapit command (https://github.com/grasph/wrapit), used to generate
# the wrapper code.
find_program(WRAPIT wrapit DOC "wrapit command path")
#FIXME: use REQUIRE option of find_program when migrating to cmake >= 3.18
if(WRAPIT STREQUAL WRAPIT-NOTFOUND)
  message(FATAL_ERROR "Failed to find wrapit executable - aborting")
else()
  message("Found wrapit executable: ${WRAPIT}")
endif()

# Define target file names based on the project name for the test
# Then write the .wit file in the build area
# This then makes sure we find the correct header from the example sources
set(WRAPIT_WIT_FILE "${CMAKE_SOURCE_DIR}/${CMAKE_PROJECT_NAME}.wit")
set(WRAPPER_LIB "jl${CMAKE_PROJECT_NAME}")
set(WRAPPER_JULIA_PACKAGE_DIR "${CMAKE_PROJECT_NAME}")
set(WRAPPER_JULIA_PACKAGE_FILE "${CMAKE_PROJECT_NAME}.jl")
#configure_file(${CMAKE_SOURCE_DIR}/${CMAKE_PROJECT_NAME}.wit.in ${CMAKE_BINARY_DIR}/${WRAPIT_WIT_FILE} @ONLY)

# Generate the wrapper code. This is done at configure time.
execute_process(
  COMMAND "${WRAPIT}" -v "${WRAPIT_VERBOSITY}" --force --update --cmake --output-prefix "${CMAKE_BINARY_DIR}" "${WRAPIT_WIT_FILE}"
  WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
  COMMAND_ECHO STDERR
  RESULT_VARIABLE result)

if(NOT result EQUAL 0)
  message(FATAL_ERROR "Execution of wrapit failed")
endif()

# File generated by wrapit that defines two variables, WRAPIT_PRODUCTS and
# WRAPIT_INPUT, with respectively the list of produced c++ code file and
# the list of files their contents on.
include("${CMAKE_BINARY_DIR}/wrapit.cmake")

# Require reconfiguration if one of the dependency of the contents produced
# by wrapit (itself executed at configure step) changed:
set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS "${WRAPIT_DEPENDS}" "${WRAPIT_WIT_FILE}")

# Build the library.
add_library(${WRAPPER_LIB} SHARED ${WRAPIT_PRODUCTS} ${WRAPPER_EXTRA_SRCS})
set_target_properties(${WRAPPER_LIB}
  PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${WRAPPER_JULIA_PACKAGE_DIR}/deps)
target_include_directories(${WRAPPER_LIB} PRIVATE ${CMAKE_SOURCE_DIR})
target_link_libraries(${WRAPPER_LIB} JlCxx::cxxwrap_julia)

# Installation paths:
set(WRAPPER_INSTALL_DIR "share/wrapit" CACHE FILEPATH "Installation path for the test modules")
install(FILES ${CMAKE_BINARY_DIR}/${WRAPPER_JULIA_PACKAGE_DIR}/src/${WRAPPER_JULIA_PACKAGE_FILE}
  DESTINATION ${WRAPPER_INSTALL_DIR}/${WRAPPER_JULIA_PACKAGE_DIR}/src)
install(TARGETS ${WRAPPER_LIB}
  LIBRARY DESTINATION  ${WRAPPER_INSTALL_DIR}/${WRAPPER_JULIA_PACKAGE_DIR}/deps
  ARCHIVE DESTINATION ${WRAPPER_INSTALL_DIR}/${WRAPPER_JULIA_PACKAGE_DIR}/deps 
  RUNTIME DESTINATION ${WRAPPER_INSTALL_DIR}/${WRAPPER_JULIA_PACKAGE_DIR}/deps)

# Help function to lower the case of the initial letter
# of a character string.
# input: the character string to transform
# output_var: the name of the variable to store the result
function(uncapitalize input output_var)
    string(SUBSTRING ${input} 0 1 FIRST_LETTER)
    string(SUBSTRING ${input} 1 -1 REMAINING_STRING)
    string(TOLOWER ${FIRST_LETTER} FIRST_LETTER_LOWER)
    set(${output_var} "${FIRST_LETTER_LOWER}${REMAINING_STRING}" PARENT_SCOPE)
endfunction()

# Setup the CTest
enable_testing()
uncapitalize(${PROJECT_NAME} TEST_SCRIPT)
set(TEST_SCRIPT "${CMAKE_SOURCE_DIR}/${TEST_SCRIPT}.jl")
set(TEST_NAME ${CMAKE_PROJECT_NAME})
add_test(NAME ${TEST_NAME} WORKING_DIRECTORY ${CMAKE_SOURCE_DIR} COMMAND env JULIA_LOAD_PATH=:${CMAKE_BINARY_DIR}/${WRAPPER_JULIA_PACKAGE_DIR}/src julia --project=.. "${TEST_SCRIPT}")
