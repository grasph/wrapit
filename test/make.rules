# Variable to define:
# MODULE_NAME: Julia module name. It needs to match with the .wit file base name.
# EXTRA_OBJS: in presence of c++ files to compile and link into the shared library other than the ones generated by wrapit.
# WRAPIT_PRODUCTS: list of c++ source file names generated from the .wit file. jl$(MODULE_NAME).cxx is added automatically.

#Destination directory of build products
BUILD_DIR=build

UNAME = $(shell uname)

JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia"))')
CXXFLAGS += $(patsubst -std=gnu%,,$(shell $(JL_SHARE)/julia-config.jl --cflags))
LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)
WRAPIT = $(shell which wrapit)
WIT_FILE = $(MODULE_NAME).wit

ifeq ($(CXXWRAP_VERSION),)
CXXWRAP_PREFIX=$(shell mkdir -p $(BUILD_DIR); julia --project=$(BUILD_DIR) -e "import Pkg; Pkg.add(\"CxxWrap\"); Pkg.resolve(); import CxxWrap; print(CxxWrap.prefix_path())")
CXXWRAP_VERSION=$(shell julia -e "import CxxWrap; print(pkgversion(CxxWrap));")
WRAPIT_OPT=--add-cfg cxxwrap_version=\"$(CXXWRAP_VERSION)\"
else
CXXWRAP_PREFIX=$(shell mkdir -p $(BUILD_DIR); julia --project=$(BUILD_DIR) -e "import Pkg; Pkg.add(name=\"CxxWrap\", version=\"$(CXXWRAP_VERSION)\"); Pkg.resolve(); import CxxWrap; print(CxxWrap.prefix_path())")
endif

WRAPIT_PRODUCTS+=jl$(MODULE_NAME).cxx
WRAPIT_ALL_PRODUCTS=lib$(MODULE_NAME)/src/$(WRAPIT_PRODUCTS)  lib$(MODULE_NAME)/src/jl$(MODULE_NAME).h $(MODULE_NAME)/src/$(MODULE_NAME).jl

CXXWRAP_CPPFLAGS=-I $(CXXWRAP_PREFIX)/include -std=c++20
LDLIBS +=-L $(CXXWRAP_PREFIX)/lib -lcxxwrap_julia -lcxxwrap_julia_stl
CXXFLAGS += -Wno-unused-variable -Wno-unused-but-set-variable -I.

CXX_IS_CLANG=$(shell $(CXX) -dM -E - < /dev/null | grep -c __clang__)

ifeq ($(UNAME),Darwin)
	SO_SUFFIX = .dylib
else
	SO_SUFFIX = .so
endif

ifneq ($(CXX_IS_CLANG), 0)
	CXXFLAGS += -ferror-limit=3
else #assuming gcc
	CXXFLAGS += -fmax-errors=3
endif

CPPFLAGS += -MMD
WRAPIT_VERBOSITY=0

LINK.o = $(CXX) $(LDFLAGS) $(TARGET_ARCH)

.PHONY: all clean test

.PRECIOUS: $(PRODUCTS)

OBJS=$(addprefix $(BUILD_DIR)/lib$(MODULE_NAME)/build/, $(addsuffix .o, $(basename $(WRAPIT_PRODUCTS))) $(EXTRA_OBJS))
#DEPS=$(patsubst %.o,%.d, $(OBJS))

PRODUCTS=$(BUILD_DIR)/$(MODULE_NAME)/deps/libjl$(MODULE_NAME)$(SO_SUFFIX) $(addprefix $(BUILD_DIR),$(WRAPIT_ALL_PRODUCTS))

all: $(PRODUCTS)

clean:
	-$(RM) -r build

# Use of % instead of $(BUILD_DIR) instructs make that the recipee produces all the targets at once and prevent multiple executions with the -j N option.
$(addprefix %,$(WRAPIT_ALL_PRODUCTS)): $(MODULE_NAME).wit
	$(WRAPIT) $(WRAPIT_OPT) -v $(WRAPIT_VERBOSITY) --force --output-prefix $(BUILD_DIR) $<

$(BUILD_DIR)/lib$(MODULE_NAME)/src/%.cxx: %.cxx
	[ -d $(@D) ] || mkdir -p $(@D)
	cp -a $< $(@D)

$(BUILD_DIR)/lib$(MODULE_NAME)/build/%.o: $(BUILD_DIR)/lib$(MODULE_NAME)/src/%.cxx
	[ -d $(@D) ] || mkdir -p $(@D)
	$(COMPILE.cc) $(CXXWRAP_CPPFLAGS) -o $@ $<

$(BUILD_DIR)/$(MODULE_NAME)/deps/libjl$(MODULE_NAME)$(SO_SUFFIX): $(OBJS)
	[ -d $(@D) ] || mkdir -p $(@D)
	$(LINK.o) -o $@ --shared -fPIC $^ $(LDLIBS)
	touch $(BUILD_DIR)/$(MODULE_NAME)/src/$(MODULE_NAME).jl

echo_%:
	 @echo $*=$($*)

test: all
	{ [ -f ./setup.sh ] && . ./setup.sh || true; } && julia run$(MODULE_NAME).jl

-include $(DEPS)

